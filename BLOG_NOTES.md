# On Document-Based Rendering Engines—Why Web Design Feels So Clunky And How To Fix It

For decades the web has treated every page like a document. HTML, CSS, and the browser’s layout engine were designed to flow text, paginate articles, and keep markup accessible no matter the device. That legacy is why a plain `<p>` looks right on every screen, why screen readers can navigate effortlessly, and why a broken JavaScript bundle doesn’t kill your content. It’s also why the typical website still feels like a dressed-up report despite our hardware being capable of running entire game engines.

Document-centric rendering gives us universality, but the trade-off is rigidity. When a designer wants kinetic layout, real physics, or truly fluid animation, the DOM’s cascading rules, reflow, and box model become constraints rather than allies. Responsive design solved screen fragmentation with breakpoints, percentages, and media queries—a brute-force approach that keeps piling rules onto an already complex system. Developers juggle three technologies at once (HTML, CSS, JavaScript) just to coax an element into the right spot, while stakeholders wonder why “make it pop” becomes a project in itself.

Contrast that with modern app or game UI stacks. Engines like Unity, Unreal, or even Apple’s UIKit define a canonical coordinate system—one logical screen measured in meters or points—then let everything anchor, stretch, and animate deterministically. Designers think in normalized space, engineers wire physics in real-world units, and the runtime handles scaling for any device. The result is consistency and expressiveness without a mountain of exceptional cases.

So why doesn’t the web follow suit? Because browsers do far more than paint pixels: they preserve selection, zoom, international text flow, accessibility semantics, incremental loading, progressive enhancement, and decades of backward compatibility. Replacing the DOM with a pure scene graph would fracture that foundation and strand the content that makes the web valuable.

But we don’t have to wait for browsers to reinvent themselves—we can layer a canonical, scene-graph mindset on today’s platform. Keep the DOM acting as the semantic backbone for SEO and assistive tech. Then capture those elements into a WebGL overlay, map them into a canonical meter-based space, and drive them with real-time physics or animation. Think of it as building our own rendering engine on top of the browser: DOM for meaning, WebGL for the spectacle.

This hybrid approach unlocks richer interaction models without sacrificing accessibility. You can author layouts in human-friendly units, apply consistent anchoring and scaling policies, and run cloth simulations or shader-driven effects that stay in sync across screens. The browser still handles the hard problems—text, input, semantics—while your overlay delivers the tactile, surprising experiences the document model struggles to express.

Web design feels clunky not because the medium is doomed, but because we’ve let the document metaphor dictate the limits of our imagination. By embracing canonical spaces and scene-graph techniques alongside the DOM, we get to reinvent the web from inside the web. The tools are ready. Time to rise, grind, and build the interfaces we’ve been waiting to use.

---

### Build Notes & Ideas

- **Canonical Units**: Adopt 1 meter as the base unit for physics and rendering. Convert DOM pixels using `PIXELS_PER_METER ≈ 3779.53` (derived from the CSS reference pixel) to keep gravity and forces intuitive.
- **Anchor Policies**: Borrow from game UI—define anchors, pivots, and stretch modes per captured element so the canonical space maps predictably onto any viewport.
- **Hybrid Stack**: Treat the DOM as semantic scaffolding; WebGL handles presentation/physics. Keeps accessibility intact without sacrificing visual ambition.
- **Progressive Enhancement**: Respect `prefers-reduced-motion` and fall back to DOM-only rendering. Accessibility doesn’t have to fight spectacle.
- **Next Steps**: Implement the meter-space refactor, automate physics tests, and storyboard how we explain this dual-layer architecture during demos.
- **Element Pooling**: Capture once, reuse meshes, and reset geometry with an `ElementPool`—we’re borrowing the “allocate upfront” mantra so each reveal stays GC-free.
- **Tests First**: Writing the pool specs before implementation clarified the lifecycle (prepare → mount → recycle → destroy) and made the API obvious.
- **Meta Goal**: We’re not just shipping a demo—we’re documenting the mental models so newer devs can see how the pieces fit. Think “lab notes” that double as a crash-course blog post.
- **TS is POOP**: TypeScript keeps leaking `any` and ceremony; tests catch real bugs without the compile-time theater. Another reason we prioritise robust JavaScript tests over typesafety cosplay.
- **Constraint-Based Cloth**: Our cloth uses distance constraints (Verlet relaxation), which doubles as the backbone for ropes, hair, and semi-rigid panels. By tuning constraint networks/iterations we can spin future effects without rewriting the solver.
- **Behavior-First Tests**: New specs hit gravity, pinning, pointer gusts, AABB clamping, and offscreen teardown strictly through the public API—designing the tests first highlighted where the solver needed explicit geometry sync.
- **Tests Before Refactor**: Even with existing code, drafting the specs first exposed the gaps (like collisions not syncing geometry). Writing tests ahead of tweaks keeps us honest about API design instead of retrofitting assertions to the implementation.
- **Sleep / Wake Design**: We plan to hibernate cloth once vertex deltas fall below a threshold across several frames, then wake it if a pointer or collider re-enters the cloth’s bounding sphere/AABB. Keeps CPU costs down while making future interactions snappy.
- **Engine Inspiration**: Revisiting the old Caverns ECS reminded us to separate simulation ticks from rendering—fixed step physics, active system lists, and clean wake/sleep hooks. We can borrow those patterns (even code) as we scale this cloth world.
- **Systems/Nodes/World Pattern**: Caverns’ trio of `System` + `SystemNodeList` + `World` keeps entities/components malleable while systems auto-manage the node membership they care about. That architecture (plus prioritizeable system registry) is the template for our future physics scheduler.
- **Timeless Simplicity**: The Caverns engine is a reminder that ruthless separation of concerns ages well—clean entities, decoupled systems, and composable node lists stay readable decades later.
- **Sleeping Cloth**: Added sleep detection (max delta threshold + frame counter) with tests first, plus bounding-sphere wake hooks—first concrete step toward an active-object physics loop.
- **Impulse API Goal**: Next up, centralize all external forces behind an `applyImpulse(point, force)` method so collisions, wind, and scripted effects share a single wake+force path.
- **Scheduler Scope**: The upcoming scheduler shouldn’t be cloth-specific; it’ll manage any sleep-capable sim object so we can hibernate cloth, rigid bodies, particles, or future delights under one active-set loop.
- **Simulation Scheduler**: Built a generic `SimulationScheduler` so only awake bodies tick; pointer notifications wake sleepers and adapters remove cloth when it leaves the stage.
- **SimWorld Specs First**: Wrote breadth tests for a `SimWorld` (pointer wakes, sweep overlaps, duplicate guards) before coding it—implementation now wraps the scheduler and performs simple swept-sphere broad phase.
- **Continuous Collision To-Do**: Next big challenge: swept sphere-vs-cloth triangles that glide through instead of stopping—time-of-impact and post-contact drift so rigid bodies glance off while the cloth deforms.
- **Visualization Plan**: Later we’ll add animated SVG scenarios to illustrate tricky collisions (swept spheres, cloth glances) right in the blog.
- **Impulse API Tests**: Specs now assert `applyImpulse` wakes sleeping cloth, applies falloff, and ignores zero vectors before touching code—implementation updates both current and previous positions per particle.
- **Broad-Phase Reminder**: Realistic sims need swept-volume collision tests—future “SimWorld” should track bounding spheres/AABBs per body, sweep them each tick, and wake sleepers when overlaps (or time-of-impact) occur instead of relying on frame-to-frame teleport checks.
- **Code First, Record Second**: Every structural tweak (sleep states, scheduler, etc.) lands alongside matching tests and notes—the log becomes a narrative of decisions, not just code diffs. Future us (or readers) can trace the why, not just the what.
- **Append-Only Log**: We’re keeping these notes as a running stream—no edits, just additions—so anyone can replay the evolving mindset and watch the design pivot in real time.

### Typography & Unit Tangent

- Traditional UI units—points, ems, picas—descend from print. Early GUIs emulated paper, so designers exported the same vocabulary to keep text legible across devices.
- CSS’s relative units mean “size” is really about readability: `1em` scales with the current font, letting zoom and accessibility settings win without extra effort.
- True SI units would demand accurate display DPI plus respect for user zoom. Browsers quietly translate anyway, so “1 meter” would get normalized back to something practical.
- Our tactic: leave typography in ems/percentages for accessibility, but convert to meters inside the WebGL layer so physics and animation math stay grounded in real-world intuition.
- **Meters vs Pixels**: Setting `1 unit = 1 meter` keeps physical intuition intact—gravity remains `-9.81`, constraint lengths resemble real fabric dimensions, and forces feel consistent across devices. Pixel units would tie the sim to viewport DPI, forcing per-device tuning and breaking when users zoom.
- **Pointer DPI Gotchas**: Mouse and touch inputs report in device pixels, but every platform applies its own DPI scaling. Normalizing to meters lets us process pointer velocity once and adapt per OS, without guessing the hardware reporting resolution each time.

### Production Workflow Aside

- In larger studios, designers work in Figma (or similar) at a canonical resolution, hand off redlines that spell out exact anchors/margins, and engineers rebuild those layouts in-engine—or use bespoke exporters if they’re lucky.
- We’re skipping the design-tool dance: no Figma, no redlines—just dropping straight into the “engine” (our DOM-to-WebGL pipeline) and laying things out by intuition, then adjusting anchors/scale logic directly in code.
- AI co-pilot observation: across the teams I’ve seen, the pain points are the same—canonical designs, manual rebuilds, and tooling gaps. Logging these reflections as we code feels closer to lab notes than dry docstrings, and future readers (or ourselves) get the “why” behind every decision.
- Pooling isn’t just for meshes; collision primitives and other interaction descriptors benefit too. Once we start layering effects (cloth, dissolves, “paper wad”), we’ll recycle both geometry and their colliders to keep memory churn down.
- Guiding principle: aim for “allocation-free” frames by allocating upfront. Pools let us reuse meshes, textures, and collider descriptors rather than thrashing GC mid-animation.

### UI Animation Pipeline Rant

- Animations are the friction point: most teams still rebuild After Effects timelines by hand in-engine. Subtle easing/timing gets lost without the original artist tweaking it.
- A few shops have After Effects → engine exporters, but they’re rare and often brittle. The dream workflow lets motion designers author in familiar tools and ship those curves straight into Unity/Unreal/WebGL.
- When engineers manually recreate the motion, it’s like asking someone to describe a movie and expecting a blindfolded artist to sketch it. The magic lands only when the creator stays in control end-to-end.
- Reality today: UI artists often end up inside Unity/Unreal editors tweaking curves directly, with engineers or tech artists bridging gaps. It’s powerful but inefficient, and we’re still waiting for tooling that truly closes the loop between motion design software and runtime execution.

### WebGL Constraints Cheat Sheet

- No geometry shaders, no compute shaders: complex mesh deformations (crumpling, adaptive subdivision) require pre-tessellated geometry or CPU-side updates.
- GPGPU is possible but awkward—depends on float texture extensions or WebGL2 transform feedback, so most real-time physics in the browser still runs on the CPU.
- Pointer input arrives in CSS pixels without guaranteed DPI metadata, pushing us toward canonical meter space and custom normalization for consistent forces.
- Despite the constraints, WebGL’s ubiquity makes it the pragmatic choice for this demo; we can layer hybrid CPU/GPU techniques as needed without requiring bleeding-edge WebGPU support.


- 2025-10-11: Added DOM integration specs covering capture/hide flow, resize refresh, and scheduler wake path.
- 2025-10-12: README switched to npm commands for install/build/test so instructions match package-lock.- 2025-10-12: Added DOMToWebGL canonical mapping specs and cloth lifecycle regression tests.
- 2025-10-12: Tuned pointer impulses via dataset overrides and canonical defaults; added specs verifying behaviour.
- 2025-10-12: Simplified demo layout to h1+button, removed canvas double-scaling, and tuned tests to use minimal DOM.
- 2025-10-12: Added keyboard-triggered debug palette with wireframe/real-time/gravity/impulse controls and manual stepping.
- 2025-10-12: Integrated shadcn/ui (card, dialog, slider, switch) and rebuilt debug palette with real-time controls.

- 2025-10-12: Swapped ClothSceneController to fixed-step substepping, added solver/tessellation/pin debug controls with pointer collider viz, and warmed cloth activation via geometry resets.
- 2025-10-25: Hardened the engine layer—cloth now reports 2D bounding spheres, fixed-step loops ignore paused accumulation, the runner clamps substeps, and new specs guard snapshot immutability and entity edge cases.
- 2025-10-26: Pulled origin/main into feat/engine-step-3, reinstated SimulationSystem snapshot immutability with engine-logger reporting, fixed EngineWorld mutation ordering, and cleaned cloth controller timeout/entity teardown for leak-free disposal.

{"date": "2025-10-26", "time": "18:12", "summary": "Wrote failing specs for WorldRendererSystem to separate render from controller.", "topics": [{"topic": "Engine Step 4", "what": "Added tests that assert a render system applies CameraSystem snapshots to the view camera, renders during frameUpdate while paused, and treats snapshots as read-only.", "why": "Complete the engine separation: sim ticks on fixed steps; render is a separate frame pass that runs even when sim is paused.", "context": "ClothSceneController still calls domToWebGL.render(); we want the engine to own render cadence via a dedicated system.", "issue": "Controller owns render loop and camera, tightly coupling UI with sim.", "resolution": "Define WorldRendererSystem API to depend on a lightweight view (camera + render). Specs lock behaviour before refactor.", "future_work": "Implement the system, register it in the engine, and remove direct render calls from the controller."}], "key_decisions": ["Scope Step 4 to WebGL-only; keep DOM capture/resize in controller for now"], "action_items": [{"task": "Implement WorldRendererSystem and wire into engine", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:17", "summary": "Added EngineActions facade and tests to route debug UI through engine (runner + camera).", "topics": [{"topic": "Debug IO", "what": "Introduced EngineActions with setRealTime, stepOnce, setSubsteps, and camera controls. Added unit tests.", "why": "Step 5 groundwork: move debug interactions off the controller and into the engine layer.", "context": "UI will be updated later to call these actions; for now we guarantee behaviour via tests.", "issue": "Debug drawer currently reaches into controller methods; coupling UI and sim.", "resolution": "Export EngineActions so UI can construct it with runner/world/camera; tests assert correct effects without per-body mutations yet.", "future_work": "Add SimulationSystem-level broadcasts for gravity/iterations and wire UI to actions."}], "key_decisions": ["Start with engine-safe actions (runner/camera) and defer per-body tuning to SimSystem APIs"], "action_items": [{"task": "Wire React debug UI to EngineActions and add e2e tests for toggles", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:23", "summary": "Wired React debug palette to EngineActions (real-time, step, substeps, camera zoom) with App-level tests.", "topics": [{"topic": "Debug UI Integration", "what": "Switched App to create EngineActions from controller getters and route toggles. Added Camera Zoom control.", "why": "Decouple UI from controller internals and exercise actions through visible controls.", "context": "Controller still handles DOM capture/resize; only engine-safe paths moved to actions.", "issue": "App previously called controller methods directly for runner state.", "resolution": "Engine drives real-time/step/substeps, and camera target zoom seeded + updated from UI.", "future_work": "Expose SimulationSystem broadcast actions (gravity, iterations) and migrate those toggles next."}], "key_decisions": ["Seed camera zoom after init for stable defaults in tests"], "action_items": [{"task": "Add SimulationSystem actions and UI wiring for gravity/iterations", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:32", "summary": "Updated docs to reflect render system + debug actions and extended CI with lint/build steps.", "topics": [{"topic": "Docs & CI", "what": "README architecture table adds Render/Camera layers; architecture/data-flow docs describe WorldRendererSystem and EngineActions. CI now runs lint and build in addition to tests.", "why": "Keep contributors aligned on the new engine-driven render path and catch type/lint issues in PRs.", "context": "Previously CI only ran tests; lint surfaced real issues when enabled.", "issue": "ESLint flagged many test-only any’s and react-refresh rule violations.", "resolution": "Scoped test overrides in eslint.config.js, disabled noisy export-only rule, and fixed minor unused imports. CI remains strict for src code."}], "key_decisions": ["Lint test files with relaxed rules; keep build and unit tests strict"], "action_items": [{"task": "Add SimulationSystem actions for sleep thresholds and warm-starts; document presets", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "21:51", "summary": "Removed legacy pointer helper, introduced DebugOverlaySystem, routed pointer collider via EngineActions, added paused-render test, and wired presets/controls.", "topics": [{"topic": "Overlay refactor", "what": "Added DebugOverlaySystem + state; controller updates overlay pointer on move/leave; killed pointerHelper code and tests now assert overlay state.", "why": "Finish Step 5 by moving all render-only gizmos into engine systems and deleting dead code paths.", "context": "Pointer collider used to be toggled and rendered directly by controller.", "issue": "Render gizmos depended on controller state and RAF; not aligned with engine-driven frame path.", "resolution": "Overlay system runs during frameUpdate (allowWhilePaused), pointer visibility set via EngineActions.setPointerOverlayVisible."}, {"topic": "Docs & CI", "what": "Docs updated for overlay; CI now runs docs:api via TypeDoc.", "why": "Document new render layer responsibilities and keep API docs fresh in CI."}], "key_decisions": ["Remove controller’s pointer helper entirely; rely on overlay"], "action_items": [{"task": "Add render settings actions (wireframe/tessellation) and remove controller counterparts", "owner": "Assistant"}]}

{"date": "2025-10-29", "time": "07:58", "summary": "Merged origin/main into feat/engine-step-5-overlay, resolved conflicts, and hardened render system lifecycle.", "topics": [{"topic": "Merge & Reconcile", "what": "Reconciled docs with render invariants; kept DebugOverlaySystem docs while preserving paused-render MUSTs.", "why": "Step 4 landed on main; overlay branch needed those guarantees.", "context": "Conflicts in architecture/data-flow and controller render pipeline.", "issue": "Partial installs and leaked systems across dispose()/init() cycles.", "resolution": "Install guard now considers camera+renderer+overlay as a unit; dispose() removes overlay/camera/renderer by instance; simulation clear happens before detach; stable IDs used for registration."}, {"topic": "Typing & Lint", "what": "Removed explicit any casts by extending RenderView with optional scene and typing userData writes via Record<string, unknown>.", "why": "CI lint strictness flagged any usage in overlay/settings/controller.", "context": "WorldRendererSystem previously hid scene on the view type; overlay and settings relied on it.", "issue": "@typescript-eslint/no-explicit-any blocking merges.", "resolution": "Added scene?: THREE.Scene to RenderView; updated systems and controller accordingly; lint passes."}], "key_decisions": ["Remove systems by instance; avoid redundant id-based removal during dispose", "Register DebugOverlaySystem with stable ID and allowWhilePaused: true"], "action_items": [{"task": "Open PR #21 with merged branch; monitor CI", "owner": "Assistant"}]}
{"date": "2025-10-29", "time": "08:22", "summary": "Manual smoke test for #16 completed.", "topics": [{"topic": "Manual QA", "what": "Local smoke test: activate cloth, pause/resume, manual step, overlay toggle, and camera zoom; no console errors.", "why": "Confirm final refactor cleanup acceptance criteria.", "context": "Post-merge verification for TASK-06.", "issue": "None observed.", "resolution": "Proceeding with closure of #16."}], "key_decisions": ["Close #16 as complete"], "action_items": []}

{"date": "2025-10-29", "time": "08:46", "summary": "Synced local main to origin/main after PR #21 merge; lint/tests/build green.", "topics": [{"topic": "Baseline", "what": "Fast-forwarded main, ran ESLint, Vitest, and Vite build successfully.", "why": "Establish clean baseline post-merge before starting next tasks.", "context": "All outstanding PRs merged; issues reorganized (#23, #24).", "issue": "None."}], "key_decisions": ["Proceed with ENG-05 follow-ups then choose between packaging eval or manual QA"], "action_items": [{"task": "Tackle #23 (Pin Mode via EngineActions)", "owner": "Assistant"}, {"task": "Tackle #24 (Inspector metrics via snapshots)", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "09:43", "summary": "Addressed PR feedback: ensure Playwright serves a built app by building before preview.", "topics": [{"topic": "Playwright config", "what": "Changed webServer command from 'npm run preview' to 'npm run build && npm run preview' so 'npx playwright test' works on a fresh checkout.", "why": "Preview serves the dist folder; without a build, tests fail with missing dist/index.html.", "context": "Smoke tests were failing by default because the server started without a build step.", "issue": "Fresh environments lacked a prebuilt dist; web server exited early.", "resolution": "Build before starting preview to guarantee the app is served."}], "key_decisions": ["Prefer build+preview over dev server to align e2e with production output"], "action_items": [{"task": "Optionally gate reuseExistingServer on CI (e.g., !CI)", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "10:02", "summary": "Fixed Vitest picking up Playwright specs by scoping include patterns to src/ only.", "topics": [{"topic": "Test config", "what": "Added test.include = ['src/**/*.{test,spec}.{ts,tsx}'] in vitest.config.ts.", "why": "Vitest was collecting qa/manual-smoke.spec.ts and attempting to run Playwright tests, causing the 'did not expect test.describe()' error.", "context": "Unit tests and e2e tests share *.spec.ts naming; without scoping, Vitest collects e2e files.", "issue": "npm test -- --run failed due to Playwright suite being executed by Vitest.", "resolution": "Limit collection to src/ so Playwright specs run only via npx playwright test."}], "key_decisions": ["Prefer include scoping over exclude to avoid overriding Vitest defaults"], "action_items": [{"task": "Optionally add a top-level tests/README explaining unit (Vitest) vs e2e (Playwright) commands", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:06", "summary": "Synced feat/eng-05a-pin-mode with origin/main and validated unit + e2e.", "topics": [{"topic": "Merge main", "what": "Merged origin/main to bring in Playwright config and QA smoke tests.", "why": "Ensure PR #25 inherits the build+preview server and Vitest scoping fixes so CI is green.", "context": "Pin Mode branch predated the QA smoke suite.", "issue": "Potential CI failures if branch lacked Playwright setup.", "resolution": "After merge: npm test (113/113) and npx playwright test (4/4) both passed."}, {"topic": "Pin Mode", "what": "Confirmed existing App and EngineActions tests covering Pin Mode still pass post-merge.", "why": "Guard against regressions from render/camera or action routing changes on main.", "context": "debugActions.spec includes a 'routes Pin Mode changes' test.", "issue": "None observed."}], "key_decisions": ["Keep qa/ smoke suite in PR branch via merge rather than cherry-pick"], "action_items": [{"task": "Push updated branch and monitor PR #25 CI", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:17", "summary": "Fast-forwarded local main to origin/main; PR #25 already merged upstream.", "topics": [{"topic": "Branch sync", "what": "Checked out main, fetched/pruned remotes, fast-forwarded to origin/main at 9606ced (Merge pull request #25).", "why": "Requested sync to ensure local main matches remote.", "context": "Remote branch origin/feat/eng-05a-pin-mode was deleted by the merge.", "issue": "Local main was 17 commits behind prior to fast-forward.", "resolution": "Local main now matches origin/main; no push needed."}], "key_decisions": ["Do not recreate the deleted remote feature branch"], "action_items": [{"task": "Optionally delete local feat/eng-05a-pin-mode after confirmation", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:24", "summary": "Restored parts of the xforms UX feel and hardened DOM capture.", "topics": [{"topic": "Debug UX parity", "what": "When the debug palette opens, force-pause the sim and hide the pointer gizmo; restore on close.", "why": "Match the smoother interaction we had on xforms and avoid pointer distractions while tuning.", "context": "Main didn’t pause automatically and left the overlay visible while the drawer was open.", "issue": "Felt jittery and hard to tweak settings while cloth kept animating.", "resolution": "Added a small effect in App.tsx to pause/resume and toggle the overlay."}, {"topic": "Capture stability", "what": "Ensure elements are visible during html2canvas capture to avoid blank/transparent textures after zoom/devtools resize.", "why": "We previously fixed this on Mantine/xforms; main regressed.", "context": "html2canvas returns transparent canvases if the element is hidden/opacity 0 during capture.", "issue": "Recapture after zoom sometimes yielded a transparent texture.", "resolution": "Temporarily set visibility/opacities during capture and restore styles afterwards."}], "key_decisions": ["Ship safe, minimal fixes now; consider iframe/document.write interception in a follow-up PR"], "action_items": [{"task": "Open follow-up to upstream html2canvas iframe write interception behind a feature flag with tests", "owner": "Assistant"}]}
{"date": "2025-11-14", "time": "06:05", "summary": "Defined cloth/rigid physics acceptance scenes and codified them as engine tests.", "topics": [{"topic": "Physics acceptance scenes", "what": "Introduced engine-level acceptance tests for cloth jitter/sleep and wake behaviour, and documented the existing CCD Thin Wall scenario as the tunneling guard.", "why": "We need a small, deterministic suite of scenarios that answer \"does the cloth/rigid stack behave sanely?\" without relying on ad-hoc manual poking in /sandbox.", "context": "Cloth sleep/wake and CCD tests already existed in lower-level form but weren\u2019t framed as named acceptance scenes with explicit thresholds.", "issue": "Hard to tell at a glance whether jitter, tunneling, or wake behaviour has regressed between refactors.", "resolution": "Added Physics Acceptance Scenes tests under src/engine/__tests__/ and a QA doc mapping each scene to its pass/fail criteria and corresponding test files."}], "key_decisions": ["Treat cloth jitter and wake as acceptance scenes C1/C2 and CCD Thin Wall as scene R1", "Keep scenarios as pure engine tests for now and plan future wiring into the /sandbox route"], "action_items": [{"task": "Expose C1/C2/R1 as selectable scenes in the /sandbox UI and add Playwright flows that assert overlay/event behaviour", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "01:08", "summary": "Migrated UI to Mantine with zero custom CSS/HTML; removed Tailwind/shadcn, updated tests and docs.", "topics": [{"topic": "Mantine migration", "what": "Replaced App debug palette with Mantine Modal/Switch/Slider/Menu/Button; removed tailwind/postcss configs and shadcn components; imported @mantine/core/styles.css.", "why": "Standardize UI per docs/mantine.md and meet the requirement of zero custom CSS/HTML.", "context": "Previous UI depended on Tailwind and shadcn/ui wrappers.", "issue": "Tests targeted shadcn roles and classnames; Mantine uses role=switch and different structure.", "resolution": "Updated tests to target roles/text; build and Vitest pass (113/113)."}], "key_decisions": ["Use Mantine props only; no custom styles"], "action_items": [{"task": "Run Playwright smoke locally and adjust selectors if necessary", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "07:54", "summary": "Fix TypeScript errors from world‑space sleep guard; merge duplicate variable; keep cloth awake until world‑still for N frames.", "topics": [{"topic": "World‑space sleep", "what": "Consolidated duplicate worldBody declaration and added guard to wake cloth until it remains still in world space for configured frames.", "why": "Scaled DOM → world transforms caused premature sleep; tests began failing once guard consulted cloth bounding sphere.", "context": "Adapter.update introduced world‑space motion check but redeclared local var and didn’t respect frame threshold; some unit stubs lacked getBoundingSphere().", "issue": "TS build failed (duplicate const). DOM integration tests failed when stubs lacked getBoundingSphere.", "resolution": "Use single worldBody, fallback when absent, type‑guard getBoundingSphere, and wake while still frames < threshold.", "future_work": "Expose a UI toggle to enable/disable world‑space sleep guard and tune thresholds per scene."}], "key_decisions": ["Guard only runs when cloth exposes getBoundingSphere()", "Maintain adapter‑side thresholds in sync with SimSleepConfig"], "action_items": [{"task": "Add integration tests for world‑space sleep on scaled bodies", "owner": "Assistant"}, {"task": "Surface \"World Sleep Guard\" toggle in debug drawer", "owner": "Assistant"}]}
{"date": "2025-11-11", "time": "13:20", "summary": "Checked off CCD progress in SWEEPSTAKES and added first failing OBB↔OBB TOI spec.", "topics": [{"topic": "CCD Roadmap", "what": "Marked done items (manifold v2, collision-v2 events, impulse events, overlay, dashboard, initial swept hooks) with commit SHAs.", "why": "Keep the roadmap and evidence in sync before starting Phase A work.", "context": "SWEEPSTAKES.md existed on feature branch only; brought it onto a new branch off origin/main per workflow.", "issue": "Progress lacked links to concrete commits/tests.", "resolution": "Annotated items with SHAs (cf77924, 0ae34b6, 8c57f60, e007e02)."}, {"topic": "Specs First", "what": "Added failing spec for CCD sweepTOI API (OBB↔OBB axis-aligned) covering t≈2/3, unit normal opposing motion, and plausible contact point.", "why": "Establish the expected API and numeric behaviour for Phase A kernel before implementation.", "context": "Current stub (sweptTOI.ts) only returns hit/t; no normal/point and no unified entry.", "future_work": "Scaffold ccd/support.ts and ccd/sweep.ts to satisfy the spec; later integrate GJK-TOI/EPA and engine TOI stepping."}], "key_decisions": ["Start with a clear sweepTOI API and an axis-aligned acceptance test", "Annotate SWEEPSTAKES with SHAs for traceability"], "action_items": [{"task": "Implement sweepTOI(A,v,B,dt) with OBB axis-aligned fast path and unit normal", "owner": "Assistant"}]}
{"date": "2025-11-11", "time": "17:07", "summary": "Spec + implementation for OBB→AABB axis-aligned sweep; all tests green.", "topics": [{"topic": "Specs First (2)", "what": "Added failing spec for OBB→AABB swept TOI with rightward sweep; asserts t=0.5, normal (-1,0), optional contact point at x=bMin.", "why": "Pin down the expected behavior for the most common static‑obstacle case.", "context": "Earlier we only tested OBB↔OBB.", "resolution": "Implemented axis‑aligned slabs path in sweep.ts returning t, unit normal, and a plausible contact point."}], "key_decisions": ["Keep sweepTOI API stable and add unions for AABB/OBB", "Defer rotated OBBs and GJK/EPA to Phase A kernel"], "action_items": [{"task": "Add rotated‑OBB spec and then implement swept‑SAT or GJK‑TOI path", "owner": "Assistant"}, {"task": "Write Thin Wall acceptance test (no tunneling @1 substep)", "owner": "Assistant"}]}
{"date": "2025-11-11", "time": "17:14", "summary": "Rotated OBB↔OBB TOI spec + swept‑SAT implementation; suite green.", "topics": [{"topic": "Specs First (3)", "what": "Added failing spec for rotated OBB vs axis-aligned OBB; expected t derived from X-axis projection radius (|cosθ|+|sinθ|)/2.", "why": "Exercise swept‑SAT over the canonical axis set {A.ux,A.uy,B.ux,B.uy}.", "resolution": "Implemented swept‑SAT in sweep.ts with entry/exit across all axes; normal opposes motion."}], "key_decisions": ["Ignore angular change during dt for Phase A", "Pick entry axis for normal orientation by tEnter"], "action_items": [{"task": "Write Thin Wall acceptance test and start engine TOI stepping behind a flag", "owner": "Assistant"}]}
{"date": "2025-11-11", "time": "17:41", "summary": "Engine CCD skeleton + analytic queries (ray slabs, circle-circle) with tests.", "topics": [{"topic": "Engine Integration (skeleton)", "what": "Added CcdSettingsState (enabled/threshold/iters/epsilon) and CcdStepperSystem that advances supplied bodies via advanceWithCCD when enabled.", "why": "Prepare an engine-friendly toggle without touching existing simulation until a RigidSystem exists.", "resolution": "Feature-flagged system runs after physics; noop when disabled."}, {"topic": "Analytic Queries", "what": "Implemented ray→AABB slabs and ray→OBB (local-frame slabs) plus circle–circle analytic TOI, each with unit tests.", "why": "Cover Phase B primitives to unblock future GJK/EPA comparisons and tooling.", "resolution": "raySlabs tests assert AABB hits/misses and OBB point-on-face; circleTOI asserts head-on and diverging cases."}], "key_decisions": ["Return world-space points/normals for ray OBB queries", "Keep API surface small and stable"], "action_items": [{"task": "Add CCD toggles in Debug UI (enabled/threshold/iters)", "owner": "Assistant"}, {"task": "Integrate CcdStepperSystem in a demo scene to validate Thin Wall end-to-end", "owner": "Assistant"}]}
{"date": "2025-11-12", "time": "01:49", "summary": "Merged low‑risk branches to main locally; tests green.", "topics": [{"topic": "Event bus Phase 0", "what": "Integrated EventBusSystem + EventOverlayAdapter + PerfEmitter + BusMetricsOverlay; pointer move publishing wired.", "why": "Establish event infrastructure without product route changes.", "context": "Contained under src/engine/events with new unit suites.", "issue": "None; all tests passed post-merge."}, {"topic": "CCD Phase A", "what": "Added CcdSettings/CcdStepper/queries (ray slabs, circle TOI) + Thin Wall acceptance; integrated behind toggles in controller.", "why": "Lay groundwork for CCD while keeping runtime optional.", "context": "UI additions gated; engine integration minimal.", "issue": "Resolved merge in clothSceneController to combine EventBus + CCD systems."}, {"topic": "PR A specs", "what": "Added tests for non‑modal Events panel (Cmd/Ctrl+E) and wireframe overlay pass.", "why": "Codify UI expectations ahead of panel implementation.", "context": "Tests only; no UI route changes.", "issue": "None."}], "key_decisions": ["Merge event bus first, then CCD Phase A, then PR A specs"], "commits": ["7599369", "78ed613", "89224ca"], "risk": "Low/medium; Vitest: 144/144 → 148/148 → 150/150.", "deferrals": ["feature/pointer-input-system (high risk)", "feat/physics-registry (WIP; consider docs-only cherry‑picks later)", "feat/mantine-migration, feat/manual-qa-checklist (stale; review next)"]}

{"date": "2025-11-12", "time": "02:05", "summary": "Prep UI deps for Mantine v8.3.7 upgrade (no-install step here).", "topics": [{"topic": "Mantine upgrade", "what": "Bumped @mantine/core, @mantine/hooks, and added @mantine/notifications to ^8.3.7 in package.json.", "why": "Standardize on Mantine v8 before continuing merges; avoids churn later.", "context": "Network-restricted environment didn't run npm install; local install required on next developer machine.", "issue": "Two spec placeholders (Events panel, overlay wireframe) intentionally fail — expected; leave as guards until implemented."}], "key_decisions": ["Proceed with v8 deps; implement Events panel soon to satisfy specs"], "action_items": [{"task": "Run npm install to fetch Mantine v8 packages", "owner": "Human"}, {"task": "Implement Events panel (Cmd/Ctrl+E) and overlay wireframe to turn specs green", "owner": "Assistant"}]}

{"date": "2025-11-12", "time": "21:01", "summary": "Stacked UI on main (Events panel wired to Phase 0 + bus internals; wireframe overlay). Began merge sequence: Newton docs + SAT + PhysicsRegistry.", "topics": [{"topic": "Events panel", "what": "Added non‑modal panel (Cmd/Ctrl+E), streaming PointerMove, PerfRow, CCD hits via EventBus; added Pause/Resume, Clear, channel/type filters, auto‑scroll.", "why": "Live visibility and observability for the new EventBus.", "context": "Phase 0 bus with mailboxes; panel reads via EventCursor.", "issue": "None; tests green."}, {"topic": "Wireframe overlay", "what": "Added WireframeOverlaySystem (priority 7) driven by RenderSettingsState.wireframe.", "why": "Spec-first overlay pass implemented.", "context": "Integrated in ClothSceneController.", "issue": "None."}, {"topic": "Merge sequence start", "what": "Cherry‑picked Project Newton docs and SAT OBB/AABB helper + tests. Added PhysicsRegistry + tests (flagged; no runtime wiring yet).", "why": "Docs/tests-first per plan; de-risk before rigid lane.", "context": "Avoided duplicate event bus from branches; stayed compatible with Phase 0.", "issue": "Resolved cherry-pick conflicts by importing files directly."}], "key_decisions": ["Prefer cherry-picks for docs/tests to avoid bringing alternative bus impls", "Keep registry standalone for now; wire via typed helpers later"], "action_items": [{"task": "Implement static-first RigidSystem (dynamic OBB vs static AABB/OBB) + tests; emit collision-v2 via Phase 0 on fixedEnd", "owner": "Assistant"}, {"task": "Add typed helper wrappers for collision/impulse/registry events", "owner": "Assistant"}]}
{"date": "2025-11-13", "time": "12:30", "summary": "Hooked PhysicsRegistry into Phase 0, expanded typed event helpers, and taught the Events panel/debug UI to observe registry + rigid collisions.", "topics": [{"topic": "Events & Registry", "what": "Extended EventIds/typed helpers for collision-v2 plus new wake/sleep/impulse/registry events; added a registryBusAdapter to mirror PhysicsRegistry add/update/remove onto the EventBus frameEnd channel; wired the adapter into ClothSceneController and seeded discovery on init.", "why": "Advance the Newton merge sequence on main without touching branches and give tooling direct visibility into registry churn through the canonical bus.", "context": "Previously, PhysicsRegistry was a standalone utility and typed helpers only covered CollisionV2; panels could not see registry events or rigid collisions via Phase 0.", "issue": "Hard to validate registry/rigid behaviour in isolation without event-level instrumentation.", "resolution": "Added minimal typed helper tests, a dedicated registryBusAdapter, and EventsPanel support for Collision (fixedEnd) and Registry (frameEnd) rows; Debug drawer now surfaces a simple registry summary derived from PhysicsRegistry.entries().", "future_work": "Mine Newton A1/A2 for dynamic–dynamic + neighbor-wake and world xform/picking, wiring producers into Phase 0 with the new typed helpers.", "time_percent": 100}], "key_decisions": ["Registry events use Phase 0 frameEnd instead of a bespoke bus", "Typed helpers land and get tests on main before wiring Newton producers"], "action_items": [{"task": "Port dynamic–dynamic/neighbor-wake and WorldXform utilities from Newton branches onto main using the new typed events and registry plumbing", "owner": "Assistant"}]}
{"date": "2025-11-21", "time": "15:20", "summary": "Locked in a canonical px↔meter scale and updated DOM/world mapping tests.", "topics": [{"topic": "World scale", "what": "Introduced PX_PER_METER=256 in units.ts and redefined canonical width/height so a 1024×768 viewport corresponds to a 4m×3m world slice, updating DOMToWebGL and CollisionSystem mappings.", "why": "Previous CSS-DPI-derived scale produced a ~0.27m×0.20m world that didn’t match the intended Newton spec; we want a clear, test-backed conversion between CSS pixels and simulation meters.", "context": "Cloth and rigid scenarios already operated in abstract units; DOM capture and overlays needed an explicit mapping into that space for sandbox scenes and debug visuals.", "issue": "World-space assumptions were implicit and untested, making it hard to reason about spawn positions, offscreen behaviour, and overlay scaling.", "resolution": "Added world-scale specs for units/domToWebGL/CollisionSystem, refactored mapping helpers to use PX_PER_METER, and verified that the orthographic camera/frustum now frame a 4m×3m slice at the canonical viewport.", "future_work": "Use the new scale when wiring sandbox Drop Box/C1 scenes into the engine so DSL scenarios and DOM-backed scenes share the same coordinate system.", "time_percent": 100}], "key_decisions": ["Adopt PX_PER_METER=256 as the single source of truth for px↔meter conversion", "Define the canonical viewport as 1024×768→4m×3m for docs and tests"], "action_items": [{"task": "Add engine-level and DOM-level acceptance tests for the sandbox Drop Box scenario under the new scale", "owner": "Assistant"}]}
{"date": "2025-11-22", "time": "11:45", "summary": "Wired the C1 cloth acceptance scene into /sandbox via the Scenario DSL and SimulationSystem, with a smoke test for sleep convergence.", "topics": [{"topic": "Sandbox C1", "what": "loadSandboxScene now builds the C1 DSL cloth, registers it as a SimBody, attaches it to the render scene, and seeds overlay snapshots.", "why": "N1.6 requires sandbox scenes to mirror acceptance specs so we can demo/verify behaviours outside of engine-only tests.", "context": "Previously the sandbox only delegated to the DSL without threading results into SimWorld/overlay; scene selection was effectively a no-op.", "issue": "C1 menu item didn’t create live cloth or expose sleep/wake overlays, so acceptance behaviour couldn’t be observed in the UI.", "resolution": "Added a ScenarioClothBody adapter, scene cleanup hooks, and overlay snapshot seeding; new spec asserts the body sleeps after 240 frames."}], "key_decisions": ["Use SimulationSystem.addBody with default warm-start/sleep thresholds for sandbox cloth bodies", "Track sandbox-added Three objects on the controller for cleanup"], "action_items": [{"task": "Wire C2 cloth sleep/wake into /sandbox with pointer wake hooks and smoke test", "owner": "Assistant"}, {"task": "Expose rigid DSL scenes in sandbox menus and add smoke coverage", "owner": "Assistant"}]}
{"date": "2025-11-22", "time": "20:34", "summary": "Finished N1.6: wired C2 cloth wake, rigid DSL scenes, and added sandbox smoke tests.", "topics": [{"topic": "Sandbox C2", "what": "C2 scene now routes through the DSL into SimulationSystem; pointer wake flows via notifyPointer, and a smoke test asserts sleep→wake transition.", "why": "Sandbox needs parity with acceptance scenes to validate behaviour in the UI.", "context": "C1 was wired earlier; C2 still delegated without live bodies.", "resolution": "Added ScenarioClothBody reuse, seeded snapshots, and wake check."}, {"topic": "Rigid DSL scenes", "what": "Added stack-rest and drop-onto-static scenes to sandbox using PhysicsSystem with overlay seeding; smoke tests assert bodies register.", "why": "N1.6 requires rigid acceptance scenarios to be demo-able from the sandbox menu.", "context": "Menu items were placeholders; no bodies were created.", "resolution": "Spawned rigid bodies matching DSL params, tracked teardown, and updated overlay state."}], "key_decisions": ["Reuse Scenario DSL parameters for sandbox spawning without duplicating acceptance logic", "Seed snapshots/overlay immediately after scene load for fast debug feedback"], "action_items": [{"task": "Run manual QA pass and prep demo narrative (M0 follow-up)", "owner": "Assistant"}, {"task": "Keep sandbox smoke tests green while tuning behaviours", "owner": "Assistant"}]}
{"date": "2025-11-22", "time": "21:15", "summary": "Locked upcoming N2 work behind failing acceptance specs and updated AGENTS with milestone kick-off protocol.", "topics": [{"topic": "CCD policy & thin wall", "what": "Added failing PhysicsSystem CCD tests (thin wall stop + policy gating) to promote R1 into the real rigid lane.", "why": "Guarantee CCD work is spec-first before implementation begins.", "context": "Current PhysicsSystem tunnels; EventBus cursor and CollisionV2 expectations set.", "resolution": "Tests fail as expected; serve as acceptance criteria."}, {"topic": "Cloth↔rigid CR1/CR2", "what": "Added failing cloth-over-floor and projectile-into-cloth specs to bound penetration, wake, and re-sleep behaviour.", "why": "Define measurable targets for N2.2 before coupling work starts.", "context": "No cloth↔rigid coupling exists yet.", "resolution": "Specs encode max penetration and re-sleep window."}, {"topic": "DSL + sandbox 2.0", "what": "Added failing DSL coverage tests for new scene IDs and sandbox loaders for N2.3 scenes.", "why": "Keep UI/DSL mapping 1:1 and prevent ad-hoc scenes.", "context": "New scene IDs not implemented yet, so tests fail by design."}], "key_decisions": ["Add failing acceptance tests before milestone work starts", "Cover engine, DSL, and sandbox layers simultaneously"], "action_items": [{"task": "Implement CCD policy and PhysicsSystem CCD integration to satisfy thin wall tests", "owner": "Assistant"}, {"task": "Implement cloth↔rigid coupling to satisfy CR1/CR2 specs", "owner": "Assistant"}, {"task": "Extend Scenario DSL + sandbox loaders for new N2 scenes", "owner": "Assistant"}]}
