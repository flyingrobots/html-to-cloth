# On Document-Based Rendering Engines—Why Web Design Feels So Clunky And How To Fix It

For decades the web has treated every page like a document. HTML, CSS, and the browser’s layout engine were designed to flow text, paginate articles, and keep markup accessible no matter the device. That legacy is why a plain `<p>` looks right on every screen, why screen readers can navigate effortlessly, and why a broken JavaScript bundle doesn’t kill your content. It’s also why the typical website still feels like a dressed-up report despite our hardware being capable of running entire game engines.

Document-centric rendering gives us universality, but the trade-off is rigidity. When a designer wants kinetic layout, real physics, or truly fluid animation, the DOM’s cascading rules, reflow, and box model become constraints rather than allies. Responsive design solved screen fragmentation with breakpoints, percentages, and media queries—a brute-force approach that keeps piling rules onto an already complex system. Developers juggle three technologies at once (HTML, CSS, JavaScript) just to coax an element into the right spot, while stakeholders wonder why “make it pop” becomes a project in itself.

Contrast that with modern app or game UI stacks. Engines like Unity, Unreal, or even Apple’s UIKit define a canonical coordinate system—one logical screen measured in meters or points—then let everything anchor, stretch, and animate deterministically. Designers think in normalized space, engineers wire physics in real-world units, and the runtime handles scaling for any device. The result is consistency and expressiveness without a mountain of exceptional cases.

So why doesn’t the web follow suit? Because browsers do far more than paint pixels: they preserve selection, zoom, international text flow, accessibility semantics, incremental loading, progressive enhancement, and decades of backward compatibility. Replacing the DOM with a pure scene graph would fracture that foundation and strand the content that makes the web valuable.

But we don’t have to wait for browsers to reinvent themselves—we can layer a canonical, scene-graph mindset on today’s platform. Keep the DOM acting as the semantic backbone for SEO and assistive tech. Then capture those elements into a WebGL overlay, map them into a canonical meter-based space, and drive them with real-time physics or animation. Think of it as building our own rendering engine on top of the browser: DOM for meaning, WebGL for the spectacle.

This hybrid approach unlocks richer interaction models without sacrificing accessibility. You can author layouts in human-friendly units, apply consistent anchoring and scaling policies, and run cloth simulations or shader-driven effects that stay in sync across screens. The browser still handles the hard problems—text, input, semantics—while your overlay delivers the tactile, surprising experiences the document model struggles to express.

Web design feels clunky not because the medium is doomed, but because we’ve let the document metaphor dictate the limits of our imagination. By embracing canonical spaces and scene-graph techniques alongside the DOM, we get to reinvent the web from inside the web. The tools are ready. Time to rise, grind, and build the interfaces we’ve been waiting to use.

---

### Build Notes & Ideas

- **Canonical Units**: Adopt 1 meter as the base unit for physics and rendering. Convert DOM pixels using `PIXELS_PER_METER ≈ 3779.53` (derived from the CSS reference pixel) to keep gravity and forces intuitive.
- **Anchor Policies**: Borrow from game UI—define anchors, pivots, and stretch modes per captured element so the canonical space maps predictably onto any viewport.
- **Hybrid Stack**: Treat the DOM as semantic scaffolding; WebGL handles presentation/physics. Keeps accessibility intact without sacrificing visual ambition.
- **Progressive Enhancement**: Respect `prefers-reduced-motion` and fall back to DOM-only rendering. Accessibility doesn’t have to fight spectacle.
- **Next Steps**: Implement the meter-space refactor, automate physics tests, and storyboard how we explain this dual-layer architecture during demos.
- **Element Pooling**: Capture once, reuse meshes, and reset geometry with an `ElementPool`—we’re borrowing the “allocate upfront” mantra so each reveal stays GC-free.
- **Tests First**: Writing the pool specs before implementation clarified the lifecycle (prepare → mount → recycle → destroy) and made the API obvious.
- **Meta Goal**: We’re not just shipping a demo—we’re documenting the mental models so newer devs can see how the pieces fit. Think “lab notes” that double as a crash-course blog post.
- **TS is POOP**: TypeScript keeps leaking `any` and ceremony; tests catch real bugs without the compile-time theater. Another reason we prioritise robust JavaScript tests over typesafety cosplay.
- **Constraint-Based Cloth**: Our cloth uses distance constraints (Verlet relaxation), which doubles as the backbone for ropes, hair, and semi-rigid panels. By tuning constraint networks/iterations we can spin future effects without rewriting the solver.
- **Behavior-First Tests**: New specs hit gravity, pinning, pointer gusts, AABB clamping, and offscreen teardown strictly through the public API—designing the tests first highlighted where the solver needed explicit geometry sync.
- **Tests Before Refactor**: Even with existing code, drafting the specs first exposed the gaps (like collisions not syncing geometry). Writing tests ahead of tweaks keeps us honest about API design instead of retrofitting assertions to the implementation.
- **Sleep / Wake Design**: We plan to hibernate cloth once vertex deltas fall below a threshold across several frames, then wake it if a pointer or collider re-enters the cloth’s bounding sphere/AABB. Keeps CPU costs down while making future interactions snappy.
- **Engine Inspiration**: Revisiting the old Caverns ECS reminded us to separate simulation ticks from rendering—fixed step physics, active system lists, and clean wake/sleep hooks. We can borrow those patterns (even code) as we scale this cloth world.
- **Systems/Nodes/World Pattern**: Caverns’ trio of `System` + `SystemNodeList` + `World` keeps entities/components malleable while systems auto-manage the node membership they care about. That architecture (plus prioritizeable system registry) is the template for our future physics scheduler.
- **Timeless Simplicity**: The Caverns engine is a reminder that ruthless separation of concerns ages well—clean entities, decoupled systems, and composable node lists stay readable decades later.
- **Sleeping Cloth**: Added sleep detection (max delta threshold + frame counter) with tests first, plus bounding-sphere wake hooks—first concrete step toward an active-object physics loop.
- **Impulse API Goal**: Next up, centralize all external forces behind an `applyImpulse(point, force)` method so collisions, wind, and scripted effects share a single wake+force path.
- **Scheduler Scope**: The upcoming scheduler shouldn’t be cloth-specific; it’ll manage any sleep-capable sim object so we can hibernate cloth, rigid bodies, particles, or future delights under one active-set loop.
- **Simulation Scheduler**: Built a generic `SimulationScheduler` so only awake bodies tick; pointer notifications wake sleepers and adapters remove cloth when it leaves the stage.
- **SimWorld Specs First**: Wrote breadth tests for a `SimWorld` (pointer wakes, sweep overlaps, duplicate guards) before coding it—implementation now wraps the scheduler and performs simple swept-sphere broad phase.
- **Continuous Collision To-Do**: Next big challenge: swept sphere-vs-cloth triangles that glide through instead of stopping—time-of-impact and post-contact drift so rigid bodies glance off while the cloth deforms.
- **Visualization Plan**: Later we’ll add animated SVG scenarios to illustrate tricky collisions (swept spheres, cloth glances) right in the blog.
- **Impulse API Tests**: Specs now assert `applyImpulse` wakes sleeping cloth, applies falloff, and ignores zero vectors before touching code—implementation updates both current and previous positions per particle.
- **Broad-Phase Reminder**: Realistic sims need swept-volume collision tests—future “SimWorld” should track bounding spheres/AABBs per body, sweep them each tick, and wake sleepers when overlaps (or time-of-impact) occur instead of relying on frame-to-frame teleport checks.
- **Code First, Record Second**: Every structural tweak (sleep states, scheduler, etc.) lands alongside matching tests and notes—the log becomes a narrative of decisions, not just code diffs. Future us (or readers) can trace the why, not just the what.
- **Append-Only Log**: We’re keeping these notes as a running stream—no edits, just additions—so anyone can replay the evolving mindset and watch the design pivot in real time.

### Typography & Unit Tangent

- Traditional UI units—points, ems, picas—descend from print. Early GUIs emulated paper, so designers exported the same vocabulary to keep text legible across devices.
- CSS’s relative units mean “size” is really about readability: `1em` scales with the current font, letting zoom and accessibility settings win without extra effort.
- True SI units would demand accurate display DPI plus respect for user zoom. Browsers quietly translate anyway, so “1 meter” would get normalized back to something practical.
- Our tactic: leave typography in ems/percentages for accessibility, but convert to meters inside the WebGL layer so physics and animation math stay grounded in real-world intuition.
- **Meters vs Pixels**: Setting `1 unit = 1 meter` keeps physical intuition intact—gravity remains `-9.81`, constraint lengths resemble real fabric dimensions, and forces feel consistent across devices. Pixel units would tie the sim to viewport DPI, forcing per-device tuning and breaking when users zoom.
- **Pointer DPI Gotchas**: Mouse and touch inputs report in device pixels, but every platform applies its own DPI scaling. Normalizing to meters lets us process pointer velocity once and adapt per OS, without guessing the hardware reporting resolution each time.

### Production Workflow Aside

- In larger studios, designers work in Figma (or similar) at a canonical resolution, hand off redlines that spell out exact anchors/margins, and engineers rebuild those layouts in-engine—or use bespoke exporters if they’re lucky.
- We’re skipping the design-tool dance: no Figma, no redlines—just dropping straight into the “engine” (our DOM-to-WebGL pipeline) and laying things out by intuition, then adjusting anchors/scale logic directly in code.
- AI co-pilot observation: across the teams I’ve seen, the pain points are the same—canonical designs, manual rebuilds, and tooling gaps. Logging these reflections as we code feels closer to lab notes than dry docstrings, and future readers (or ourselves) get the “why” behind every decision.
- Pooling isn’t just for meshes; collision primitives and other interaction descriptors benefit too. Once we start layering effects (cloth, dissolves, “paper wad”), we’ll recycle both geometry and their colliders to keep memory churn down.
- Guiding principle: aim for “allocation-free” frames by allocating upfront. Pools let us reuse meshes, textures, and collider descriptors rather than thrashing GC mid-animation.

### UI Animation Pipeline Rant

- Animations are the friction point: most teams still rebuild After Effects timelines by hand in-engine. Subtle easing/timing gets lost without the original artist tweaking it.
- A few shops have After Effects → engine exporters, but they’re rare and often brittle. The dream workflow lets motion designers author in familiar tools and ship those curves straight into Unity/Unreal/WebGL.
- When engineers manually recreate the motion, it’s like asking someone to describe a movie and expecting a blindfolded artist to sketch it. The magic lands only when the creator stays in control end-to-end.
- Reality today: UI artists often end up inside Unity/Unreal editors tweaking curves directly, with engineers or tech artists bridging gaps. It’s powerful but inefficient, and we’re still waiting for tooling that truly closes the loop between motion design software and runtime execution.

### WebGL Constraints Cheat Sheet

- No geometry shaders, no compute shaders: complex mesh deformations (crumpling, adaptive subdivision) require pre-tessellated geometry or CPU-side updates.
- GPGPU is possible but awkward—depends on float texture extensions or WebGL2 transform feedback, so most real-time physics in the browser still runs on the CPU.
- Pointer input arrives in CSS pixels without guaranteed DPI metadata, pushing us toward canonical meter space and custom normalization for consistent forces.
- Despite the constraints, WebGL’s ubiquity makes it the pragmatic choice for this demo; we can layer hybrid CPU/GPU techniques as needed without requiring bleeding-edge WebGPU support.


- 2025-10-11: Added DOM integration specs covering capture/hide flow, resize refresh, and scheduler wake path.
- 2025-10-12: README switched to npm commands for install/build/test so instructions match package-lock.- 2025-10-12: Added DOMToWebGL canonical mapping specs and cloth lifecycle regression tests.
- 2025-10-12: Tuned pointer impulses via dataset overrides and canonical defaults; added specs verifying behaviour.
- 2025-10-12: Simplified demo layout to h1+button, removed canvas double-scaling, and tuned tests to use minimal DOM.
- 2025-10-12: Added keyboard-triggered debug palette with wireframe/real-time/gravity/impulse controls and manual stepping.
- 2025-10-12: Integrated shadcn/ui (card, dialog, slider, switch) and rebuilt debug palette with real-time controls.

- 2025-10-12: Swapped ClothSceneController to fixed-step substepping, added solver/tessellation/pin debug controls with pointer collider viz, and warmed cloth activation via geometry resets.
- 2025-10-25: Hardened the engine layer—cloth now reports 2D bounding spheres, fixed-step loops ignore paused accumulation, the runner clamps substeps, and new specs guard snapshot immutability and entity edge cases.
- 2025-10-26: Pulled origin/main into feat/engine-step-3, reinstated SimulationSystem snapshot immutability with engine-logger reporting, fixed EngineWorld mutation ordering, and cleaned cloth controller timeout/entity teardown for leak-free disposal.

{"date": "2025-10-26", "time": "18:12", "summary": "Wrote failing specs for WorldRendererSystem to separate render from controller.", "topics": [{"topic": "Engine Step 4", "what": "Added tests that assert a render system applies CameraSystem snapshots to the view camera, renders during frameUpdate while paused, and treats snapshots as read-only.", "why": "Complete the engine separation: sim ticks on fixed steps; render is a separate frame pass that runs even when sim is paused.", "context": "ClothSceneController still calls domToWebGL.render(); we want the engine to own render cadence via a dedicated system.", "issue": "Controller owns render loop and camera, tightly coupling UI with sim.", "resolution": "Define WorldRendererSystem API to depend on a lightweight view (camera + render). Specs lock behaviour before refactor.", "future_work": "Implement the system, register it in the engine, and remove direct render calls from the controller."}], "key_decisions": ["Scope Step 4 to WebGL-only; keep DOM capture/resize in controller for now"], "action_items": [{"task": "Implement WorldRendererSystem and wire into engine", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:17", "summary": "Added EngineActions facade and tests to route debug UI through engine (runner + camera).", "topics": [{"topic": "Debug IO", "what": "Introduced EngineActions with setRealTime, stepOnce, setSubsteps, and camera controls. Added unit tests.", "why": "Step 5 groundwork: move debug interactions off the controller and into the engine layer.", "context": "UI will be updated later to call these actions; for now we guarantee behaviour via tests.", "issue": "Debug drawer currently reaches into controller methods; coupling UI and sim.", "resolution": "Export EngineActions so UI can construct it with runner/world/camera; tests assert correct effects without per-body mutations yet.", "future_work": "Add SimulationSystem-level broadcasts for gravity/iterations and wire UI to actions."}], "key_decisions": ["Start with engine-safe actions (runner/camera) and defer per-body tuning to SimSystem APIs"], "action_items": [{"task": "Wire React debug UI to EngineActions and add e2e tests for toggles", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:23", "summary": "Wired React debug palette to EngineActions (real-time, step, substeps, camera zoom) with App-level tests.", "topics": [{"topic": "Debug UI Integration", "what": "Switched App to create EngineActions from controller getters and route toggles. Added Camera Zoom control.", "why": "Decouple UI from controller internals and exercise actions through visible controls.", "context": "Controller still handles DOM capture/resize; only engine-safe paths moved to actions.", "issue": "App previously called controller methods directly for runner state.", "resolution": "Engine drives real-time/step/substeps, and camera target zoom seeded + updated from UI.", "future_work": "Expose SimulationSystem broadcast actions (gravity, iterations) and migrate those toggles next."}], "key_decisions": ["Seed camera zoom after init for stable defaults in tests"], "action_items": [{"task": "Add SimulationSystem actions and UI wiring for gravity/iterations", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "18:32", "summary": "Updated docs to reflect render system + debug actions and extended CI with lint/build steps.", "topics": [{"topic": "Docs & CI", "what": "README architecture table adds Render/Camera layers; architecture/data-flow docs describe WorldRendererSystem and EngineActions. CI now runs lint and build in addition to tests.", "why": "Keep contributors aligned on the new engine-driven render path and catch type/lint issues in PRs.", "context": "Previously CI only ran tests; lint surfaced real issues when enabled.", "issue": "ESLint flagged many test-only any’s and react-refresh rule violations.", "resolution": "Scoped test overrides in eslint.config.js, disabled noisy export-only rule, and fixed minor unused imports. CI remains strict for src code."}], "key_decisions": ["Lint test files with relaxed rules; keep build and unit tests strict"], "action_items": [{"task": "Add SimulationSystem actions for sleep thresholds and warm-starts; document presets", "owner": "Assistant"}]}

{"date": "2025-10-26", "time": "21:51", "summary": "Removed legacy pointer helper, introduced DebugOverlaySystem, routed pointer collider via EngineActions, added paused-render test, and wired presets/controls.", "topics": [{"topic": "Overlay refactor", "what": "Added DebugOverlaySystem + state; controller updates overlay pointer on move/leave; killed pointerHelper code and tests now assert overlay state.", "why": "Finish Step 5 by moving all render-only gizmos into engine systems and deleting dead code paths.", "context": "Pointer collider used to be toggled and rendered directly by controller.", "issue": "Render gizmos depended on controller state and RAF; not aligned with engine-driven frame path.", "resolution": "Overlay system runs during frameUpdate (allowWhilePaused), pointer visibility set via EngineActions.setPointerOverlayVisible."}, {"topic": "Docs & CI", "what": "Docs updated for overlay; CI now runs docs:api via TypeDoc.", "why": "Document new render layer responsibilities and keep API docs fresh in CI."}], "key_decisions": ["Remove controller’s pointer helper entirely; rely on overlay"], "action_items": [{"task": "Add render settings actions (wireframe/tessellation) and remove controller counterparts", "owner": "Assistant"}]}

{"date": "2025-10-29", "time": "07:58", "summary": "Merged origin/main into feat/engine-step-5-overlay, resolved conflicts, and hardened render system lifecycle.", "topics": [{"topic": "Merge & Reconcile", "what": "Reconciled docs with render invariants; kept DebugOverlaySystem docs while preserving paused-render MUSTs.", "why": "Step 4 landed on main; overlay branch needed those guarantees.", "context": "Conflicts in architecture/data-flow and controller render pipeline.", "issue": "Partial installs and leaked systems across dispose()/init() cycles.", "resolution": "Install guard now considers camera+renderer+overlay as a unit; dispose() removes overlay/camera/renderer by instance; simulation clear happens before detach; stable IDs used for registration."}, {"topic": "Typing & Lint", "what": "Removed explicit any casts by extending RenderView with optional scene and typing userData writes via Record<string, unknown>.", "why": "CI lint strictness flagged any usage in overlay/settings/controller.", "context": "WorldRendererSystem previously hid scene on the view type; overlay and settings relied on it.", "issue": "@typescript-eslint/no-explicit-any blocking merges.", "resolution": "Added scene?: THREE.Scene to RenderView; updated systems and controller accordingly; lint passes."}], "key_decisions": ["Remove systems by instance; avoid redundant id-based removal during dispose", "Register DebugOverlaySystem with stable ID and allowWhilePaused: true"], "action_items": [{"task": "Open PR #21 with merged branch; monitor CI", "owner": "Assistant"}]}
{"date": "2025-10-29", "time": "08:22", "summary": "Manual smoke test for #16 completed.", "topics": [{"topic": "Manual QA", "what": "Local smoke test: activate cloth, pause/resume, manual step, overlay toggle, and camera zoom; no console errors.", "why": "Confirm final refactor cleanup acceptance criteria.", "context": "Post-merge verification for TASK-06.", "issue": "None observed.", "resolution": "Proceeding with closure of #16."}], "key_decisions": ["Close #16 as complete"], "action_items": []}

{"date": "2025-10-29", "time": "08:46", "summary": "Synced local main to origin/main after PR #21 merge; lint/tests/build green.", "topics": [{"topic": "Baseline", "what": "Fast-forwarded main, ran ESLint, Vitest, and Vite build successfully.", "why": "Establish clean baseline post-merge before starting next tasks.", "context": "All outstanding PRs merged; issues reorganized (#23, #24).", "issue": "None."}], "key_decisions": ["Proceed with ENG-05 follow-ups then choose between packaging eval or manual QA"], "action_items": [{"task": "Tackle #23 (Pin Mode via EngineActions)", "owner": "Assistant"}, {"task": "Tackle #24 (Inspector metrics via snapshots)", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "09:43", "summary": "Addressed PR feedback: ensure Playwright serves a built app by building before preview.", "topics": [{"topic": "Playwright config", "what": "Changed webServer command from 'npm run preview' to 'npm run build && npm run preview' so 'npx playwright test' works on a fresh checkout.", "why": "Preview serves the dist folder; without a build, tests fail with missing dist/index.html.", "context": "Smoke tests were failing by default because the server started without a build step.", "issue": "Fresh environments lacked a prebuilt dist; web server exited early.", "resolution": "Build before starting preview to guarantee the app is served."}], "key_decisions": ["Prefer build+preview over dev server to align e2e with production output"], "action_items": [{"task": "Optionally gate reuseExistingServer on CI (e.g., !CI)", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "10:02", "summary": "Fixed Vitest picking up Playwright specs by scoping include patterns to src/ only.", "topics": [{"topic": "Test config", "what": "Added test.include = ['src/**/*.{test,spec}.{ts,tsx}'] in vitest.config.ts.", "why": "Vitest was collecting qa/manual-smoke.spec.ts and attempting to run Playwright tests, causing the 'did not expect test.describe()' error.", "context": "Unit tests and e2e tests share *.spec.ts naming; without scoping, Vitest collects e2e files.", "issue": "npm test -- --run failed due to Playwright suite being executed by Vitest.", "resolution": "Limit collection to src/ so Playwright specs run only via npx playwright test."}], "key_decisions": ["Prefer include scoping over exclude to avoid overriding Vitest defaults"], "action_items": [{"task": "Optionally add a top-level tests/README explaining unit (Vitest) vs e2e (Playwright) commands", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:06", "summary": "Synced feat/eng-05a-pin-mode with origin/main and validated unit + e2e.", "topics": [{"topic": "Merge main", "what": "Merged origin/main to bring in Playwright config and QA smoke tests.", "why": "Ensure PR #25 inherits the build+preview server and Vitest scoping fixes so CI is green.", "context": "Pin Mode branch predated the QA smoke suite.", "issue": "Potential CI failures if branch lacked Playwright setup.", "resolution": "After merge: npm test (113/113) and npx playwright test (4/4) both passed."}, {"topic": "Pin Mode", "what": "Confirmed existing App and EngineActions tests covering Pin Mode still pass post-merge.", "why": "Guard against regressions from render/camera or action routing changes on main.", "context": "debugActions.spec includes a 'routes Pin Mode changes' test.", "issue": "None observed."}], "key_decisions": ["Keep qa/ smoke suite in PR branch via merge rather than cherry-pick"], "action_items": [{"task": "Push updated branch and monitor PR #25 CI", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:17", "summary": "Fast-forwarded local main to origin/main; PR #25 already merged upstream.", "topics": [{"topic": "Branch sync", "what": "Checked out main, fetched/pruned remotes, fast-forwarded to origin/main at 9606ced (Merge pull request #25).", "why": "Requested sync to ensure local main matches remote.", "context": "Remote branch origin/feat/eng-05a-pin-mode was deleted by the merge.", "issue": "Local main was 17 commits behind prior to fast-forward.", "resolution": "Local main now matches origin/main; no push needed."}], "key_decisions": ["Do not recreate the deleted remote feature branch"], "action_items": [{"task": "Optionally delete local feat/eng-05a-pin-mode after confirmation", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "18:24", "summary": "Restored parts of the xforms UX feel and hardened DOM capture.", "topics": [{"topic": "Debug UX parity", "what": "When the debug palette opens, force-pause the sim and hide the pointer gizmo; restore on close.", "why": "Match the smoother interaction we had on xforms and avoid pointer distractions while tuning.", "context": "Main didn’t pause automatically and left the overlay visible while the drawer was open.", "issue": "Felt jittery and hard to tweak settings while cloth kept animating.", "resolution": "Added a small effect in App.tsx to pause/resume and toggle the overlay."}, {"topic": "Capture stability", "what": "Ensure elements are visible during html2canvas capture to avoid blank/transparent textures after zoom/devtools resize.", "why": "We previously fixed this on Mantine/xforms; main regressed.", "context": "html2canvas returns transparent canvases if the element is hidden/opacity 0 during capture.", "issue": "Recapture after zoom sometimes yielded a transparent texture.", "resolution": "Temporarily set visibility/opacities during capture and restore styles afterwards."}], "key_decisions": ["Ship safe, minimal fixes now; consider iframe/document.write interception in a follow-up PR"], "action_items": [{"task": "Open follow-up to upstream html2canvas iframe write interception behind a feature flag with tests", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "01:08", "summary": "Migrated UI to Mantine with zero custom CSS/HTML; removed Tailwind/shadcn, updated tests and docs.", "topics": [{"topic": "Mantine migration", "what": "Replaced App debug palette with Mantine Modal/Switch/Slider/Menu/Button; removed tailwind/postcss configs and shadcn components; imported @mantine/core/styles.css.", "why": "Standardize UI per docs/mantine.md and meet the requirement of zero custom CSS/HTML.", "context": "Previous UI depended on Tailwind and shadcn/ui wrappers.", "issue": "Tests targeted shadcn roles and classnames; Mantine uses role=switch and different structure.", "resolution": "Updated tests to target roles/text; build and Vitest pass (113/113)."}], "key_decisions": ["Use Mantine props only; no custom styles"], "action_items": [{"task": "Run Playwright smoke locally and adjust selectors if necessary", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "07:54", "summary": "Fix TypeScript errors from world‑space sleep guard; merge duplicate variable; keep cloth awake until world‑still for N frames.", "topics": [{"topic": "World‑space sleep", "what": "Consolidated duplicate worldBody declaration and added guard to wake cloth until it remains still in world space for configured frames.", "why": "Scaled DOM → world transforms caused premature sleep; tests began failing once guard consulted cloth bounding sphere.", "context": "Adapter.update introduced world‑space motion check but redeclared local var and didn’t respect frame threshold; some unit stubs lacked getBoundingSphere().", "issue": "TS build failed (duplicate const). DOM integration tests failed when stubs lacked getBoundingSphere.", "resolution": "Use single worldBody, fallback when absent, type‑guard getBoundingSphere, and wake while still frames < threshold.", "future_work": "Expose a UI toggle to enable/disable world‑space sleep guard and tune thresholds per scene."}], "key_decisions": ["Guard only runs when cloth exposes getBoundingSphere()", "Maintain adapter‑side thresholds in sync with SimSleepConfig"], "action_items": [{"task": "Add integration tests for world‑space sleep on scaled bodies", "owner": "Assistant"}, {"task": "Surface \"World Sleep Guard\" toggle in debug drawer", "owner": "Assistant"}]}

{"date": "2025-10-30", "time": "09:24", "summary": "Add World Sleep Guard toggle + tessellation min/max caps with tests; keep DOM overlay toggles stable.", "topics": [{"topic": "Debug controls", "what": "Added Drawer controls for World Sleep Guard, Auto Tessellation toggle, and Min/Max caps.", "why": "Let us A/B world-space sleep behavior and tune tri counts per screen coverage.", "context": "Users reported immediate sleep on click; also requested tessellation bounds to avoid huge tri counts.", "issue": "Previous guard was always-on and tessellation only had a single cap slider.", "resolution": "Expose guard toggle; computeAutoSegments now respects auto on/off and min/max bounds; controller methods added with tests."}, {"topic": "Tests", "what": "Extended domIntegration specs to cover world-space guard (on/off) and tessellation caps.", "why": "Lock behavior under transforms and ensure bounds respected.", "context": "Reuse existing mocks to keep tests simple."}], "key_decisions": ["Do optional-calls to new controller methods in App to avoid breaking existing App tests that mock the controller"], "action_items": [{"task": "Consider promoting caps into EngineActions to unify with controller methods later", "owner": "Assistant"}]}
{"date": "2025-11-01", "time": "08:48", "summary": "Synced feat/world-sleep-guard-and-tessellation-options with origin/main; resolved conflicts; converted modal drawer to non‑modal Affix panel; addressed overlay disposal, pointer anisotropy, world sleep guard typing and warnings, and tessellation auto/min/max behaviour; tests + lint green.", "topics": [{"topic": "PR #32 status", "what": "Merged latest from origin/main (no rebase); branch contains Mantine migration; kept world-sleep guard toggle, typed SimWorld snapshot, and tessellation controls; non-modal debug panel.", "why": "Bring branch up to date and address review feedback blocking merge.", "context": "Previous Drawer UI blocked interactions; pointer collider scaling/teleport bugs; GPU leaks in overlay; presets changed camera zoom; inconsistent Pin Mode defaults; tessellation controls inert.", "resolution": "Affix palette (non-modal) with controlled Selects; overlay clear/dispose; 2D pointer circle with ortho anisotropy compensation and uniform fallback; presets now cloth-only; default Pin Mode = 'none'; added setTessellationSegments(force) and auto/min/max re-bake; world-sleep guard warnings + typed snapshot.", "future_work": "Optional: Accordion sections in palette; expose EngineActions helpers for tessellation caps; touch UX tuning for small screens.", "time_percent": 100}], "key_decisions": ["Keep WebGL z-index at 1000 and set debug palette zIndex=2100 for layering clarity", "Prefer non-modal Affix to persistent debug controls", "Warn once if getBoundingSphere is unavailable to surface test/mock gaps"], "action_items": [{"task": "Consider collapsible sections in DebugPalette and responsive docking", "owner": "Assistant"}], "branch": "%s", "tests": "116/116", "lint": "ok"}
{"date": "2025-11-01", "time": "09:02", "summary": "Refactor DebugPalette into Mantine Accordion sections (Presets, Physics, Tessellation, Sleep & Warm Start, Overlays, View). Keep aria-labels and test selectors stable; open Sleep/View by default to satisfy integration tests; add Menu-based Pin Mode trigger (button) for reliable keyboardable control; preserve paused Step button.", "topics": [{"topic": "UI re-org", "what": "Replaced long stack with collapsible groups using Mantine Accordion; moved Pin Mode to a Menu trigger inside Presets; broke Sleep panel into separate stacks per slider to keep DOM scoping predictable for tests.", "why": "Requested non-modal panel with collapsible/always-available sections; improve scanability; resolve test fragility after structure change.", "context": "Drawers felt modal and hid controls; tests were querying by role within nearest row and required visible sections.", "resolution": "Accordion with default open sections [presets, physics, sleep, view]; added Pin Mode Menu; maintained all aria-labels; Step control remains visible when paused.", "future_work": "Optional: make sections user-persisted (localStorage) and allow drag/dock of panel.", "time_percent": 100}], "key_decisions": ["Open Sleep/View by default to keep sliders accessible to tests", "Use Menu instead of Select for Pin Mode to provide an explicit button role"], "branch": "%s", "tests": "116/116", "lint": "ok"}
{"date": "2025-11-01", "time": "09:04", "summary": "Make debug panel cloth-enabled and drop on Hide; add controller.clothify(element) API to prepare/activate elements post-init; keep panel always capturable (hide via opacity/pointer-events).", "topics": [{"topic": "Debug panel cloth", "what": "Added clothify() to controller and wired Hide to clothify the DebugPalette Paper; removed Affix hidden prop in favor of opacity/pointer-events.", "why": "Wanted the panel to peel off like the hero button on demand.", "context": "Initial capture only scanned .cloth-enabled at init; needed a runtime API to on-demand prepare and activate an element.", "resolution": "Public clothify(element, {activate, addClickHandler}) mirrors prepareElements+activate; App calls it before closing the panel.", "future_work": "Maybe an API to undo/restore to static without full recycle.", "time_percent": 100}], "branch": "feat/world-sleep-guard-and-tessellation-options", "tests": "116/116", "lint": "ok"}
